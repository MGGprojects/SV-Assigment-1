-- Members:
-- Mauro Gómez Guillén
-- Solomon Fanta

MODULE Switches(goal_straight, goal_curved)

  VAR
    status : {straight, moving,curved};

  ASSIGN
    init(status) := moving;
    next(status) := case
      goal_straight&status = curved : moving;
      goal_curved& status = straight : moving;
      status = moving & goal_straight : {moving, straight};
      status = moving & goal_curved   : {moving, curved};
      TRUE : status;
    esac;
	
	FAIRNESS !(status = moving)

MODULE Train (
        train_id,
        may_approach_A, may_approach_B,
        S2A_red,S3A_red,S4A_red,
        S2B_red,S3B_red,S4B_red,
        S2A_green,S3A_green,S4A_green,
        S2B_green,S3B_green,S4B_green,
        S1A_red,S1A_green,S1B_red,S1B_green,
        P1A_locked_straight,P1A_locked_curved,
        P1B_locked_straight,P1B_locked_curved,
        P2A_locked_straight,P2A_locked_curved,
        P2B_locked_straight,P2B_locked_curved
  )

  VAR
    location : {
            T1A,T2A,T3A,T4A,T1B,T2B,T3B,T4B,T0A,T0B,T00
        };
    in_bound : boolean;

  ASSIGN
    init(in_bound) := TRUE;


    next(in_bound) := case
      location=T00 : TRUE;
      location=T3A : FALSE;
      location=T3B : FALSE;
      TRUE : in_bound;
    esac;
    
    init(location) := T00;
    
    next(location) := case
      location=T00 &  may_approach_A &  may_approach_B : { T00 , T0A , T0B };
      location=T00 &  may_approach_A & !may_approach_B : { T00 , T0A };
      location=T00 & !may_approach_A &  may_approach_B : { T00 , T0B };
      location=T00 & !may_approach_A & !may_approach_B : T00;
      
      location=T0A & in_bound  : T1A;
      location=T0A & !in_bound : T00;
      location=T0B & in_bound  : T1B;
      location=T0B & !in_bound : T00;
      
      location=T1A & in_bound  & S2A_green : T2A;
      location=T1A & !in_bound & S1A_green : T0A;
      location=T1B & in_bound  & S2B_green : T2B;
      location=T1B & !in_bound & S1B_green : T0B;
      
      location=T2A & in_bound & P1A_locked_straight : T3A ;
      location=T2A & in_bound & P1A_locked_curved : T4B ;
      location=T2A & !in_bound : T1A;
      location=T2B & in_bound & P1B_locked_straight : T3B ;
      location=T2B & in_bound & P1B_locked_curved : T4A ;
      location=T2B & !in_bound : T1B;

      location=T4A & in_bound : T3A ;
      location=T4A & !in_bound & P2A_locked_curved : T2B ;
      location=T4B & in_bound : T3B ;
      location=T4B & !in_bound & P2B_locked_curved : T2A ;
      
      location=T3A & !in_bound & S4A_green : T4A;
      location=T3B & !in_bound & S4B_green : T4B;

      TRUE:location;

    esac;


MODULE Environment(
        S2A_red,S3A_red,S4A_red,S2B_red,S3B_red,S4B_red,S2A_green,S3A_green,S4A_green,
        S2B_green,S3B_green,S4B_green,
        P1A_goal_straight,P1A_goal_curved, P1B_goal_straight,P1B_goal_curved,
        P2A_goal_straight,P2A_goal_curved, P2B_goal_straight,P2B_goal_curved    
    )
    
  DEFINE
    -- track occupation train1
    T1A_occupied_train1 := train1.location = T1A;
    T2A_occupied_train1 := train1.location = T2A;
    T3A_occupied_train1 := train1.location = T3A;
    T4A_occupied_train1 := train1.location = T4A;
    T1B_occupied_train1 := train1.location = T1B;
    T2B_occupied_train1 := train1.location = T2B;
    T3B_occupied_train1 := train1.location = T3B;
    T4B_occupied_train1 := train1.location = T4B;
    
    -- track occupation for train2
    T1A_occupied_train2 := train2.location = T1A;
    T2A_occupied_train2 := train2.location = T2A;
    T3A_occupied_train2 := train2.location = T3A;
    T4A_occupied_train2 := train2.location = T4A;
    T1B_occupied_train2 := train2.location = T1B;
    T2B_occupied_train2 := train2.location = T2B;
    T3B_occupied_train2 := train2.location = T3B;
    T4B_occupied_train2 := train2.location = T4B;
    
    -- combined track occupation (so any train)
    T1A_occupied := T1A_occupied_train1 | T1A_occupied_train2;
    T2A_occupied := T2A_occupied_train1 | T2A_occupied_train2;
    T3A_occupied := T3A_occupied_train1 | T3A_occupied_train2;
    T4A_occupied := T4A_occupied_train1 | T4A_occupied_train2;
    T1B_occupied := T1B_occupied_train1 | T1B_occupied_train2;
    T2B_occupied := T2B_occupied_train1 | T2B_occupied_train2;
    T3B_occupied := T3B_occupied_train1 | T3B_occupied_train2;
    T4B_occupied := T4B_occupied_train1 | T4B_occupied_train2;
    
    -- Signal occupancy (entry signals are occupied when any train is on entry track)
    S1A_red   := train1.location = T0A | train2.location = T0A; 
    S1B_red   := train1.location = T0B | train2.location = T0B;
    S1A_green := !S1A_red;
    S1B_green := !S1B_red;
    
    -- status of switch
    P1A_locked_straight := P1A.status=straight;
    P1B_locked_straight := P1B.status=straight;
    P2A_locked_straight := P2A.status=straight;
    P2B_locked_straight := P2B.status=straight;
    P1A_locked_curved := P1A.status=curved;
    P2A_locked_curved := P2A.status=curved;
    P1B_locked_curved := P1B.status=curved;
    P2B_locked_curved := P2B.status=curved;
    
    -- restrictions for the approach to avoid collisions on entry
    -- restrict approach A if any train is exiting or about to exit via side A
    may_approach_A := !(train1.location = T3A | train2.location = T3A | 
                       (train1.location = T4A & !train1.in_bound) | 
                       (train2.location = T4A & !train2.in_bound));
    
    -- Restrict approach B if any train is exiting or about to exit via side B  
    may_approach_B := !(train1.location = T3B | train2.location = T3B |
                       (train1.location = T4B & !train1.in_bound) |
                       (train2.location = T4B & !train2.in_bound));
    
  VAR
    P1A : Switches(P1A_goal_straight,P1A_goal_curved);
    P1B : Switches(P1B_goal_straight,P1B_goal_curved);
    P2A : Switches(P2A_goal_straight,P2A_goal_curved);
    P2B : Switches(P2B_goal_straight,P2B_goal_curved);
    train1 : Train(
        1,
        may_approach_A, may_approach_B,
        S2A_red,S3A_red,S4A_red,
        S2B_red,S3B_red,S4B_red,
        S2A_green,S3A_green,S4A_green,
        S2B_green,S3B_green,S4B_green,
        S1A_red,S1A_green,S1B_red,S1B_green,
        P1A_locked_straight,P1A_locked_curved,
        P1B_locked_straight,P1B_locked_curved,
        P2A_locked_straight,P2A_locked_curved,
        P2B_locked_straight,P2B_locked_curved
    );
    train2 : Train(
        2,
        may_approach_A, may_approach_B,
        S2A_red,S3A_red,S4A_red,
        S2B_red,S3B_red,S4B_red,
        S2A_green,S3A_green,S4A_green,
        S2B_green,S3B_green,S4B_green,
        S1A_red,S1A_green,S1B_red,S1B_green,
        P1A_locked_straight,P1A_locked_curved,
        P1B_locked_straight,P1B_locked_curved,
        P2A_locked_straight,P2A_locked_curved,
        P2B_locked_straight,P2B_locked_curved
    );

  -- the following is for collision prevention, ie, no two trains on same track
  TRANS !(next(T1A_occupied_train1) & next(T1A_occupied_train2));
  TRANS !(next(T2A_occupied_train1) & next(T2A_occupied_train2));
  TRANS !(next(T3A_occupied_train1) & next(T3A_occupied_train2));
  TRANS !(next(T4A_occupied_train1) & next(T4A_occupied_train2));
  TRANS !(next(T1B_occupied_train1) & next(T1B_occupied_train2));
  TRANS !(next(T2B_occupied_train1) & next(T2B_occupied_train2));
  TRANS !(next(T3B_occupied_train1) & next(T3B_occupied_train2));
  TRANS !(next(T4B_occupied_train1) & next(T4B_occupied_train2));